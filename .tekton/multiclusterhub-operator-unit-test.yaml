apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: multiclusterhub-operator-unit-test
spec:
  params:
    - name: SNAPSHOT
      value: '{"components": [{"name":"test-app", "containerImage": "quay.io/example/repo:latest"}]}'
    - name: NAMESPACE
      value: "default"
    - name: EXPECTED_OUTPUT
      value: ""
  pipelineSpec:
    params:
      - name: SNAPSHOT
        type: string
      - name: NAMESPACE
        type: string
      - name: EXPECTED_OUTPUT
        type: string
    tasks:
      - name: unit-test
        params:
          - name: SNAPSHOT
            value: $(params.SNAPSHOT)
          - name: NAMESPACE
            value: $(params.NAMESPACE)
          - name: EXPECTED_OUTPUT
            value: $(params.EXPECTED_OUTPUT)
        retries: 3
        taskSpec:
          params:
            - name: SNAPSHOT
            - name: NAMESPACE
            - name: EXPECTED_OUTPUT
          results:
            - name: TEST_OUTPUT
          steps:
            - name: run-tests
              image: golang:1.20
              script: |
                #!/bin/bash
                set -e

                # Install dependencies
                apt-get update && apt-get install -y jq git make

                # Runtime Env Config
                export GOPATH=$HOME/go

                go install github.com/onsi/ginkgo/ginkgo@latest
                go install gotest.tools/gotestsum@latest

                # Set Vars
                TARGET_COMPONENT_NAME="multiclusterhub-operator"
                REPO_URL=$(echo $SNAPSHOT | jq -r '.components[] | select(.name == "maestro").source.git.url')
                REPO_COMMIT=$(echo $SNAPSHOT | jq -r '.components[] | select(.name == "maestro").source.git.revision')
                test_output_file=${PWD}/test_output.json

                # Clone Repo and checkout at snapshot commit
                git clone $REPO_URL $TARGET_COMPONENT_NAME
                cd $TARGET_COMPONENT_NAME
                git fetch origin
                git checkout $REPO_COMMIT

                # Run unit tests with JSON output
                make test unit_test_json_output="$test_output_file"

                # Process test output
                FAILURES=$(jq -r '. | select(.Action == "fail") | length' < "$test_output_file")
                SUCCESSES=$(jq -r '. | select(.Action == "pass") | length' < "$test_output_file")
                WARNINGS=0
                RESULT=$(if [[ $FAILURES -eq 0 ]]; then echo "SUCCESS"; else echo "FAILURE"; fi)
                TIMESTAMP=$(date +%s)
                TEST_OUTPUT=$(jq -n \
                  --arg result "$RESULT" \
                  --argjson successes "$SUCCESSES" \
                  --argjson failures "$FAILURES" \
                  --argjson warnings "$WARNINGS" \
                  --arg timestamp "$TIMESTAMP" \
                  '{result: $result, successes: $successes, failures: $failures, warnings: $warnings, timestamp: $timestamp}')

                echo -n "$TEST_OUTPUT" | tee $(results.TEST_OUTPUT.path)
